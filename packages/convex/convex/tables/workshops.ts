import { defineTable } from "convex/server";
import { v } from "convex/values";

// ── Registration mode ────────────────────────────────────────────────
// Organizer chooses ONE per workshop. Validated at publish time.
export const registrationModeValidator = v.union(
  v.object({ type: v.literal("open") }),
  v.object({
    type: v.literal("capped"),
    maxCapacity: v.number(),
    waitlistEnabled: v.boolean(),
  }),
  v.object({
    type: v.literal("approval"),
    maxCapacity: v.optional(v.number()),
  }),
  v.object({
    type: v.literal("level_gated"),
    minLevel: v.number(),
    maxCapacity: v.optional(v.number()),
  }),
);

// ── Publication state ────────────────────────────────────────────────
// Only tracks organizer-controlled transitions: draft → scheduled → published → archived.
//
// Time-derived display states (computed at query/render time, never stored):
//   upcoming : published && now < startDate
//   live     : published && startDate <= now <= endDate
//   ended    : published && now > endDate
//
// This avoids cron-based state transitions that could fail and leave data
// in an impossible state (e.g., "live" after endDate has passed).
export const publicationStateValidator = v.union(
  v.object({ type: v.literal("draft") }),
  v.object({
    type: v.literal("scheduled"),
    scheduledAt: v.number(), // When to auto-publish (independent of startDate)
  }),
  v.object({ type: v.literal("published") }),
  v.object({ type: v.literal("archived") }),
);

// ── Workshops table ──────────────────────────────────────────────────
export const workshopsTable = defineTable({
  title: v.string(),
  image: v.optional(v.id("_storage")), // Optional for drafts, required on publish
  description: v.string(),
  startDate: v.number(),
  endDate: v.number(),
  creatorId: v.id("users"),
  communityId: v.id("communities"),

  location: v.union(
    v.object({
      type: v.literal("online"),
      link: v.string(),
    }),
    v.object({
      type: v.literal("in-person"),
      address: v.string(),
      instructions: v.optional(v.string()),
    }),
  ),

  publicationState: publicationStateValidator,
  registrationMode: v.optional(registrationModeValidator), // Optional for drafts, required on publish

  coHosts: v.array(v.id("users")),
  tags: v.array(v.string()),

  // Attendance check-in code, generated by organizer during the live window.
  // Mutation-enforced: can only be set/used when startDate <= now <= endDate.
  checkInCode: v.optional(v.string()),

  // Denormalized counter — kept in sync by registration mutations.
  // Actual registrations live in the workshopRegistrations table.
  registrationCount: v.number(),
  recentRegistrations: v.array(v.id("users")),
})
  .index("by_communityId", ["communityId"])
  .index("by_communityId_and_startDate", ["communityId", "startDate"])
  .index("by_publicationState_and_startDate", [
    "publicationState.type",
    "startDate",
  ])
  .searchIndex("search_workshops", {
    searchField: "title",
  });
